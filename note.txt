TODO:
1. continue to learn KeyValueHeap.java which is used in RegionScannerImpl to
do store merges

Question:
1. can a client call one region server to get data from another one?
  A: in the current implementation, NO. I current understanding is that, the
     RSRpcServer still need to extract the region information from GetRequest
     as RSRpcServer and HRegion do not form a 1-to-1 binding. One physical
     server may host multiple HRegions, but only one RSRpcServer.
2. which object caches region server info on the client side?
  A: HConnection, whose implementation is 
     ConnectionManager.HConnectionImplementation.
3. how does the server side achieves concurrency?
  A: In the RpcServer.java, the listener has a fixed number of Readers in an
     ExecutorPool, 10 by default.

Remember:
1. getStub() returns a ClientService.BlockingInterface object
2. APPEND, INCREMENT, PUT, DELETE are all encapsulated by a mutate request. 
   But it seems that the encapsulation for the PUT request is never used.
   Instead, every PUT request is handled using the multi() API exposed by
   the RSRpcServices. Remaining actions are handled using mutate.

Call Traces:
0. init RPC info:
  RPC CLIENT SIDE:
  client/HTable.java      333     initialize the configuration based on
                                  ClusterConeciton.getConfiguration().
                                  This configuration was later passed to
                                  RpcControllerFactory.instantiate(...) to
                                  create a new rpcControllerFactory. Then the
                                  RpcControllerFactory object is passed to the
                                  AsyncProcess constructor to grant it 
                                  knowledge about the RPC info.
  ipc/rpcControllerFactory.java
                          56      based on the information in the configuration
                                  it creates a new RpcControllerFactory using
                                  ReflectionUtils.instantiateWithCustomCtor.
1. get request
  RPC CLIENT SIDE:
  client/HTable.java      801     get() declares a subclass of abstract class
                                  RegionServerCallable at line 728. In that 
                                  definition, it constructs the request object 
                                  by calling 
                                  RequestConverter.buildGetRequest(), then the
                                  get request is issued using 
                                  ClientService.BlockingInterface.get().
                                    In order to get the right region servers
                                  to query with, RegionServerCallable has a 
                                  field location, which can be returned by 
                                  calling getLocation(). The location field
                                  is initialized by 
                                  HConnection.getRegionLocation() whose impl is
                                  ConnectionManager.HConnectionImplementation.
  client/ConnectionManager.java
                          464     class HConnectionImplementation locates the
                                  correct set of region servers by calling
                                  locateRegion(...) on line 982. If the info
                                  is in cache, Registry.getMetaRegionLocation()
                                  will return it. Otherwise, it calls 
                                  locateRegionInMeta() on line 995.
  client/ConnectionManager.java
                          1003    locateRegionInMeta() first checks if it
                                  should look into the cache on line 1008.
                                  getCachedLocation(table, row) returns the in
                                  cache data. MetaScanner.getHRegionInfor()
                                  on line 1060 converts the row result to
                                  HRegionLocation.

  protobuf/RequestConverter.java
                          157     buildGetReuest() calls 
                                  buildRegionSpecifier() on line 159 to build
                                  a RegionSpecifier. Then it uses 
                                  GetRequest.Builder to build the GetRequest.
                                  The GetRequest contains the encoded name of
                                  the target region, which is passed through
                                  the RPC call.


  RPC SERVER SIDE:
  hbase-server/regionserver/...
  RSRpcServices.java      1562    get() first identify the right region to
                                  query by translating the encoded name of 
                                  the region into an HRegion object.
                                  Then it calls HRegion.getClosestRowBefore()
                                  and HRegion.get() on line 1583 and 1590
                                  respectively.
  HRegion.java            4735    Result get() wraps List<Cell> get()
                                  method on line 4747.
  HRegion.java            4756    List<Cell> get() calls RegionScanner.next()
                                  on line 4773.
  HRegion.java            3698    RegionScannerImpl implements the interface
                                  RegionScanner.
  HRegion.java            3817    next() calls nextRaw() on line 3826, which
                                  then calls nextInternal() on line 3847.
  HRegion.java            3918    nextInternal()

2. scan request
  RPC SERVER SIDE:
  RSRpcService.java       1798    scan(). 

3. put request
  Surprisingly, the put request is done IN BATCH on the client side.
  RPC CLIENT SIDE:
  hbase-client/...
  client/HTable.java      965     put() calls doPut().
  client/HTable.java      982     doPut() first add the put request into 
                                  its writeAsyncBuffer. When the buffer size
                                  is larger than a threshold, it calls
                                  backgroundFlushCommits() to the server side.
  client/HTable.java      1009    backgroundFlushCommits() calls 
                                  AsyncProcess.submit() to push the changes.
  client/AsyncProcess.java
                          277     submit(...) calls createAsyncRequestFuture()
                                  which in turn constructs an 
                                  AsyncRequestFutureImpl object, then it calls
                                  AsyncRequestFutureImpl.sendMultiAction() to
                                  flush the actions.
  client/AsyncProcess.java
                          513     class AsyncRequestFutureImpl
  client/AsyncProcess.java
                          586     AsyncRequestFutureImpl.sendMultiAction()
                                  calls RpcRetryingCaller.callWithoutRetries() 
                                  on line 602 to send actions and wait for
                                  results. The callable implementation is 
                                  MultiServerCallable
  client/MultiServerCallable.java
                          84      call() finally gives controller
                                  and the requestProto to the 
                                  ClientService.blockingInterface.multi() to 
                                  get the response.

  RPC SERVER SIDE:
  hbase-server/.../regionserver/
  RSRpcServices.java      1626    multi() gets the RpcController and the
                                  MultiRequest objects through RPC. It then
                                  calls mutateRows(...) on line 1663.
  RSRpcServices.java      348     mutateRows(...) adds the put actions into
                                  row mutations object by using 
                                  ProtobufUtil.toPut. Then it calls
                                  HRegion.mutateRow().
  HRegion.java            4798    mutateRow(...) after a few thin warppers,
                                  it call reaches processRowsWithLocks on 
                                  line 4851.

4. split a region
  RPC CLIENT SIDE:
  hbase-client/...
  client/HBaseAdmin.java  2007    split() calls the ProtobufUtil.split()
                                  method.
  protobuf/ProtobufUtil.java
                          1691    split() wraps the
                                  AdminService.BlockingInterface.splitRegion()
                                  RPC method.
                          

  RPC SERVER SIDE:
  hbase-server/regionserver/...
  RSRpcServices.java      683     The constructor exposes its own services
                                  to the rpcServer by calling getServices()
                                  on line 713.
  RSRpcServices.java      818     getServices() returns a list of all RPC
                                  services provided by RSRpcServices including 
                                  RSRpcServices.splitRegion() by 
                                  calling newReflectiveBlockingService(this),
                                  AdminService and ClientService are generated
                                  classes under
                                  hbase-protocol/.../protobuf/generaged.
                                  more about google's protobuf at:
                                  https://code.google.com/p/protobuf/
  RSRpcServices.java      1435    splitRegion() calls HRegion.checkSplit() 
                                  on line 1449 to get splitpoints. It then
                                  calls HRegion.startRegionOperation() to 
                                  acquire the lock. After that, it calls 
                                  HRegion.forceSplit() to set the split flag
                                  and splitting points. Finally, it calls
                                  CompactSplitThread.requestSplit() to force
                                  instant split.
  CompactSplitThread.java 214     requestSplit() uses a SplitRequest object as
                                  a parameter when calling
                                  ThreadPoolExecutor.execute() to execute the
                                  split request on line 221.
  SplitRequest.java       57      run() calls  SplitTransaction.execute() on
                                  line 82 to execute the split transaction.
  SplitTransaction.java   565     execute() calls createDaughters() which in
                                  turn calls stepsBeforePONR() to create two
                                  daughter regions. Then it calls
                                  stepsAfterPONR() which in turn calls 
                                  openDaughters() to open the two daughter 
                                  regions.
  HRegion.java            5658    checkSplit() calls 
                                  RegionSplitPolicy.getSplitPoint() on line 
                                  5678 to get split points
  RegionSplitPolicy.java          as an abstract class has two implementations
                                  IncreasingToUpperBoundRegionSplitPolicy.java
                                  and ConstantSizeRegionSplitPolicy.java

5. data format
